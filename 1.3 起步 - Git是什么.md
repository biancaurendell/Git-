# 1.3 起步 - Git是什么?

## 直接记录快照，而非差异比较

* 主要区别在于git 对待数据的方式(CVS、 Subversion、Perforce是以文件变更的方式储存信息，将他们储存的信息看做是一组基本文件和每个文件随时间逐步积累的差异，通常称作基于差异(delta-based)的版本控制)

  ![存储每个文件与初始版本的差异。](https://git-scm.com/book/en/v2/images/deltas.png)

* 储存每个文件与初始版本的差异。
  * Git不按照上面方法保存数据，它是把数据看做对小型文件系统的一系列快照。在git中每当你提交更新或保存项目状态时，他基本上就会对当时的全部文件创建一个快照并保存这个快照的索引为了效率，如果文件没有修改，git将不再重新储存该文件，而是只保留一个链接只想之前储存的文件。![Git 存储项目随时间改变的快照。](https://git-scm.com/book/en/v2/images/snapshots.png)Git对待数据更像是一个 **快照流**

* 储存项目随时间改变的快照
  * 这是GIT与几乎所有其它版本控制系统的重要区别，git更像是一个小型的文件系统，提供了许多以此为基础构件的超强工具，而不只是一个简单的VCS

## 近乎所有的操作都是本地执行

* git不需要连接到服务器去获取历史，它只需要从本地数据库中读取。你能立即看到项目历史，若果你想查看当前版本与一个月之前的版本之间引入的修改，git会查找到一个月前的文件做一次差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理
* 这意味着你在离线或者没有VPN时，几乎可以进行任何操作，可以提交修改到本地副本，直到有网络连接时再上传。甚至能换成别的系统也能上传

## Git保证完整性

* Git中所有的数据在储存前都计算校验和，然后以校验和来引用，这意味着不可能在Git不知情时更改任何文件内容或目录内容，这个功能构件在Git底层，是构成Git哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git就能发现

* 计算校验和的机制是 SHA-1散列 （hash,哈希)。这是一个由40个十六机制字符（0-9和a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来

  * ```
    24b9da6552252987aa493b52f8696cd6d3b00373
    ```

## Git一般只添加数据

* 执行的Git操作，几乎只往Git数据库中**添加**数据。你很难从Git数据库中删除数据，也就是说Git几乎不可能会执行任何导致文件不可恢复的操作。
* 这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 更深度探讨 Git 如何保存数据及恢复丢失数据的话题，请参考[撤消操作](https://git-scm.com/book/zh/v2/ch00/_undoing)。

## 三种状态

### 已提交（committed)

* 表示数据已经安全地保存在本地数据库中。

### 已修改（modified）

* 表示修改了文件，但还没保存到数据库中。

### 已暂存（staged)

* 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。

**上述的三种状态会到时Git项目拥有三个阶段：工作区、暂存区以及Git目录。**

![img](https://git-scm.com/book/en/v2/images/areas.png)

### 工作目录、暂存区域以及Git仓库

* **工作区**:是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
* **暂存区**:是一个文件，保存了下次将要提交的文件列表信息，一般在Git仓库目录中。按照Git的术语叫做**"索引"**
* **Git仓库目录：**是Git用来保存项目的元数据和对象数据库的地方。这是Git中的最重要的部分，从其他计算机克隆仓库时，复制的就是这里的数据。
* 基本的Git工作流程如下
  * 在工作区中修改文件
  * 将你想要下次提交的更改选择性暂存，这样只会讲更改的部分添加到暂存区
  * 提交更新，找到暂存区的文件，将快照永久性粗存到Git目录。

## 总结

如果 Git 目录中保存着特定版本的文件，就属于 **已提交** 状态。 如果文件已修改并放入暂存区，就属于 **已暂存** 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 **已修改** 状态。 在 [Git 基础](https://git-scm.com/book/zh/v2/ch00/ch02-git-basics-chapter) 一章，你会进一步了解这些状态的细节， 并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。